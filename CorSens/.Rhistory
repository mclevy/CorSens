if (is.null(mu) == T){
mu_x <- c(colMeans(data, na.rm=T))
}else{
mu_x <- mu
}
# print(sigma)
A <- t(chol(sigma)) # check: A %*% t(A) = sigma ; sigma is just correlated vars
x <- t( apply(A %*% t(xt), MARGIN=2, FUN=function(x){x + mu_x}))
# pairs(x[sample(nrow(x),10^3), ])
## x_p = cbind(y_tp, z_tp) with rotating col=i as y_tp; the rest (-i) cols are z_tp
# x_tp matrix is UNCORRELATED standard normal variables = no transformation using sigma
u_p <- matrix(runif(k * N), nrow = N) # k-dim uniform sample, u_p
xt_p <- qnorm(u_p) # transform to standard normal
# pairs(xt_p[sample(nrow(x),10^3), ])
## Calculate mu's = mu_y, mu_z: For matrix x, mu_y is colMeans of the y "subset" col (i) for each subset; mu_z is the colMeans of the remaining (-i) cols of x.
Mu_x <- colMeans(x)
# Mu_xt_p <- colMeans(xt_p) # not used below
#########################################################################
### Construct set (y, z_bp)
## compute mu_zc using y; from eqn.(3.4): mu_zc = mu_z + sigma_zy %*% solve(sigma_y) %*% (y-mu_y)
st <- seq(1,q*k,by=q) ; end <- seq(q,k*q, by=q) # index
Mu_zc <- matrix(NA, nrow = q*k, ncol=N)
# computes Mu_zc for each subset i = 1:3, for each N samples
for (i in 1:k){
# partitioned sigma matrix: same for all subsets of x
sigma_y <- matrix(sigma[i,i])
sigma_zy <- matrix(sigma[i,-i])
Mu_zc[st[i]:end[i], ] <- apply(sigma_zy %*% solve(sigma_y) %*% (x[ ,i] - Mu_x[i]), MARGIN=2, FUN=function(x){x + matrix(Mu_x[-i])})
}
##  compute z_bp (bp = bar, prime); zt_p = xt_p[ ,-i]; z_bp = A_zc %*% z_tp + mu_zc; which follows (q = k-s)-dim conditional normal distribution in eq.(3.3)
Z_bp <- matrix(NA, nrow = q*k, ncol=N)
for (i in 1:k){
sigma_y <- sigma[i,i]
sigma_yz <- sigma[-i,i]
sigma_zy <- sigma[i,-i]
sigma_z <- sigma[-i,-i]
sigma_zc <- sigma_z - sigma_zy %*% solve(sigma_y) %*% sigma_yz
A_zc <- t(chol(sigma_zc))
Z_bp[st[i]:end[i], ] <- apply(xt_p[ ,-i], MARGIN=c(1), FUN=function(x){A_zc %*% x}) + Mu_zc[st[i]:end[i], ]
}
## create vector (y,z_bp)
nst <- seq(1,k*N,by=N) ; nend <- seq(N,k*N, by=N)
Y.Z_bp <- matrix(NA, nrow = k*N, ncol=k)
for (i in 1:k){
Y.Z_bp[nst[i]:nend[i],i] <- x[,i]
Y.Z_bp[nst[i]:nend[i],-i] <- t(Z_bp[st[i]:end[i], ])
}
## copula: transform normals to arbitrary marginal distribution
# Normal CDF
Y.Z_bp <- Fnorm(Y.Z_bp) # Uniforms
# Arbitrary quantile
Y.Z_bp <- Ginv(Y.Z_bp, distributions, params)
# Y.Z_bp: subsets of 1:N each, with rotating col i as the original col from x, z from Z_bp transform of z (-i) cols of xt_p
#########################################################################
### Construct (complimentary) set (y_bp, z)
## From above: xt_p = cbind(y_tp, z_tp) with rotating col=i as y_tp => y_tp = xt_p[ ,i]; the rest (-i) are z_tp
## compute mu_yc using z (from x[ ,-i]); mu_yc = mu_y + sigma_yz %*% solve(sigma_z) %*% (z-mu_z)
Mu_yc <- matrix(NA, nrow = 1*k, ncol=N)
for (i in 1:k){
sigma_yz <- sigma[-i,i]
sigma_z <- sigma[-i,-i]
Mu_yc[i, ] <- apply(sigma_yz %*% solve(sigma_z) %*% apply(x[ ,-i], MARGIN=1, FUN=function(x){x - Mu_x[-i]}), MARGIN=2, FUN=function(x){x + Mu_x[i]})
}
## compute y_bp (bp = bar, prime); y_bp = A_yc %*% y_tp + mu_yc; which follows 1-dim conditional normal distribution
Y_bp <- matrix(NA, nrow = 1*k, ncol=N)
for (i in 1:k){
# partitioned sigma matrix: same for all subsets of x
sigma_y <- sigma[i,i]
sigma_yz <- sigma[-i,i]
sigma_zy <- sigma[i,-i]
sigma_z <- sigma[-i,-i]
sigma_yc <- sigma_y - sigma_yz %*% solve(sigma_z) %*% sigma_zy
A_yc <- t(chol(sigma_yc)) # A_yc %*% t(A_yc)
Y_bp[i, ] <- apply(matrix(xt_p[ ,i]), MARGIN=c(1), FUN=function(x){A_yc %*% x} ) + Mu_yc[i, ]
}
##  create vector cbind(y_bp,z)
Y_bp.Z <- matrix(NA, nrow = k*N, ncol=k)
for (i in 1:k){
Y_bp.Z[nst[i]:nend[i],i] <- Y_bp[i, ]
Y_bp.Z[nst[i]:nend[i],-i] <-  x[,-i]
}
## copula: transform normals to arbitrary marginal distribution
# Normal CDF
Y_bp.Z <- Fnorm(Y_bp.Z) # Uniforms
# Arbitrary quantile
Y_bp.Z <- Ginv(Y_bp.Z, distributions, params)
# Y_bp.Z: subsets of 1:N each, with rotating col i as the Y_bp col from transformed xt_p (i) cols; z from original x (-i)
#########################################################################
### Construct joint set (y, z)
# Joint set (y,z) is just the original x matrix x=(y,z); the "y" will be the rotating col i, and the z the (-i) cols for i = 1,...,k
## copula: transform normals to arbitrary marginal distribution
# Normal CDF
Y.Z <- Fnorm(x) # Uniforms
# Arbitrary quantile
Y.Z <- Ginv(Y.Z, distributions, params)
mod <- model
hist(Y.Z[ ,1]) ; hist(Y.Z[ ,2]); hist(Y.Z[ ,3])
hist(Y.Z_bp[ ,1]) ; hist(Y.Z_bp[ ,2]); hist(Y.Z_bp[ ,3])
hist(Y_bp.Z[ ,1]) ; hist(Y_bp.Z[ ,2]); hist(Y_bp.Z[ ,3])
round(cor(Y.Z),1)
round(cor(Y.Z_bp),1)
round(cor(Y_bp.Z),1)
fboot <- function(X) sample(X, size=N, replace=TRUE)
Y.Z_boot <- apply(Y.Z,2,fboot)
Y.Z_bp_boot <- apply(Y.Z_bp,2,fboot)
Y_bp.Z_boot <- apply(Y_bp.Z,2,fboot)
hist(Y.Z_boot[ ,1]) ; hist(Y.Z_boot[ ,2]); hist(Y.Z_boot[ ,3])
hist(Y.Z_bp_boot[ ,1]) ; hist(Y.Z_bp_boot[ ,2]); hist(Y.Z_bp_boot[ ,3])
hist(Y_bp.Z_boot[ ,1]) ; hist(Y_bp.Z_boot[ ,2]); hist(Y_bp.Z_boot[ ,3])
round(cor(Y.Z_boot),1)
round(cor(Y.Z_bp_boot),1)
round(cor(Y_bp.Z_boot),1)
332*.1
?lme
??lme
?glm
library(lme4)
setwd("C:/Documents and Settings/XPMUser/Desktop/Hierarchical Modeling Spring 2013")
getwd()
library(lme4)
install.packages("lme4")
?factor
?glm
?lme4
lme4
lme
?lme
library(nlme)
?lme
fm1 <- lme(distance ~ age, data = Orthodont)
summary(fm1)
names(fm1)
summary(z)
plot(z)
fm2 <- lme(distance ~ age + Sex, data = Orthodont, random = ~ 1)
plot(fm1)
intervals(fm1)
resid(fm1)
fitted(fm1)
VarCorr(fm1)
anova(fm1)
anova(fm1, fm2)
>lmer
?lmer
library(lme4)
?lmer
(fm1 <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy))
fm1 <- lmer(distance ~ age, data = Orthodont)
(fm1 <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy))
summary(fm1)
(fm2 <- lmer(Reaction ~ Days + (1|Subject) + (0+Days|Subject), sleepstudy))
anova(fm1, fm2)
print(fm2, digits=7, ranef.comp="Var")
print(fm2, digits=7, ranef.comp="Var") # the print.merMod()         method
print(sm2, digits=3, corr=FALSE)
sm2 <- summary(fm2)
print(sm2, digits=3, corr=FALSE)
vv <- vcov.merMod(fm2, corr=TRUE)
vv
as(vv, "corMatrix")
model_lmer<-lmer(distance~age+Sex+(1|Subject),data=Orthodont)
model_lme<-lme(distance~age+Sex, random=~1|Subject,data=Orthodont)
summary(model_lmer)
anova(model_lmer)
summary(model_lme)
summary(model_lme)
anova(model_lme)
plot(ranef(model_lme)) # lme
qqmath(ranef(model_lmer))
res_lme=residuals(model_lme)
plot(res_lme)
qqnorm(res_lme)
qqline(res_lme)
plot(model_lme)
res_lme=residuals(model_lmer)
plot(res_lme)
plot(res_lmer)
res_lmer=residuals(model_lmer)
plot(res_lmer)
qqnorm(res_lmer)
qqline(res_lmer)
plot(model_lmer)
plot(model_lmer)
model_lme<-lme(distance ~ age + factor(Sex),random = ~ 1 | Subject, cor=corAR1(0.6,form=~1|Subject),data = Orthodont)
VarCorr(model_lme)
library(lmerTest)
install.packages("lmerTest")
?lmerTest
m <- lmer(Informed.liking ~ Gender+Information+Product +(1|Consumer), data=ham)
library(lmerTest)
fm1 <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
summary(fm1)# (with its own print method)
anova(fm1)
?lmer
library(lmerTest)
fm1 <- lmer(Reaction ~ Days + (Days|Subject), sleepstudy)
fm1 <- lmer(Reaction ~ Days + (Days|Subject), sleepstudy)
fm2 <- lmer(Reaction ~ Days + (1|Subject) + (0+Days|Subject), sleepstudy)
anova(fm1)
rm(list= ls());
master <- "/Users/mcl/Desktop"
data <- read.csv("drought.csv")
getwd()
setwd(master)
getwd()
data <- read.csv("drought.csv")
data
?binom.test
which(drought[ ,'Year'] %in% 1906:1999)
which(data[ ,'Year'] %in% 1906:1999)
i20 <- which(data[ ,'Year'] %in% 1906:1999)
i21 <- which(data[ ,'Year'] %in% 2000:2013)
names(data)
sum(data[i20,"Drought"]
)
length(i20)
bt20 <- binom.test(sum(data[i20,"Drought"]), length(i20), p = 0.5) # p is null of drought/no-drought being equally likely
bt20
binom.test(c(682, 243), p = 3/4)
binom.test(682, 682 + 243, p = 3/4)
bt21 <- binom.test(sum(data[i21,"Drought"]), length(i21), p = 0.5)
bt21
tail(data,1)
nrow(data)+1
data[109,] <- c(2014,0)
data
data <- read.csv("drought.csv")
data[109,] <- c(2014,NA) # no drought
dta
data
i20 <- which(data[ ,'Year'] %in% 1906:1999)
i21 <- which(data[ ,'Year'] %in% 2000:2013)
i21d <- which(data[ ,'Year'] %in% 2000:2014)
i21d
i21
bt20 <- binom.test(sum(data[i20,"Drought"]), length(i20), p = 0.5) # reject null, p of success is 0.30, p-value = 0.0002617 (significant)
bt21 <- binom.test(sum(data[i21,"Drought"]), length(i21), p = 0.5) # fail to reject the null, p of success is 0.42, p-value = 0.7905 (not significant)
bt20
data[109,"Drought"] <- c(0) # no drought
data[109,"Drought"]
data
bt21d0 <- binom.test(sum(data[i21d,"Drought"]), length(i21d), p = 0.5)
bt21d0
data[109,"Drought"] <- c(1) # drought
data
i21d
bt21d1 <- binom.test(sum(data[i21d,"Drought"]), length(i21d), p = 0.5)
bt21d1
tb <- matrix(NA, c(2,2))
tb
tb <- matrix(NA, nrow=2, ncol=2)
matrix(c(5,45,10,35),c(2,2))
tb <- matrix(NA, nrow=2, ncol=2)
tb
?matrix
tb <- matrix(NA, nrow=2, ncol=2, dimnames = list(c("i20", "i21"), c("D", "N-D")))
tb
sum(data[i20,"Drought"])
length(i20)
length(i20) - sum(data[i20,"Drought"])
65+29
sum(data[i21,"Drought"])
tb["i20","D"] <- sum(data[i20,"Drought"])
tb["i20","N-D"] <- length(i20) - sum(data[i20,"Drought"])
tb["i21","D"] <- sum(data[i21,"Drought"])
tb["i21","N-D"] <- length(i21) - sum(data[i21,"Drought"])
tb
ct <- chisq.test(tb)
ct
?chisq.test
data[109,"Drought"] <- c(0) # no drought
data
sum(data[i21d,"Drought"])
sum(data[i21,"Drought"])
length(i21d)
ength(i21)
length(i21)
tb["i21","D"] <- sum(data[i21d,"Drought"])
tb["i21","N-D"] <- length(i21d) - sum(data[i21d,"Drought"])
tb
ctd0 <- chisq.test(tb)
ctd0
data[109,"Drought"] <- c(1) # drought
tb["i21","D"] <- sum(data[i21d,"Drought"])
tb["i21","N-D"] <- length(i21d) - sum(data[i21d,"Drought"])
ctd1 <- chisq.test(tb)
ctd1
hist(data[i20, "Drought"])
hist(data[i21, "Drought"])
tb <- matrix(NA, nrow=2, ncol=2, dimnames = list(c("i20", "i21"), c("D", "N-D")))
tb["i20","D"] <- sum(data[i20,"Drought"])
tb["i20","N-D"] <- length(i20) - sum(data[i20,"Drought"])
tb["i21","D"] <- sum(data[i21,"Drought"])
tb["i21","N-D"] <- length(i21) - sum(data[i21,"Drought"])
ft <- fisher.test(tb)
ft
data[109,"Drought"] <- c(0) # no drought
data
tb["i21","D"] <- sum(data[i21d,"Drought"])
tb["i21","N-D"] <- length(i21d) - sum(data[i21d,"Drought"])
tb
ftd0 <- fisher.test(tb)
ftd0
data[109,"Drought"] <- c(1) # drought
tb["i21","D"] <- sum(data[i21d,"Drought"])
tb["i21","N-D"] <- length(i21d) - sum(data[i21d,"Drought"])
ftd1 <- fisher.test(tb)
ftd1
1906:2014/2
108/2
rownames(data)
i1 <- 1:54
i2 <- 55:108
i2d <- 55:109
data[i1,]
data[i2,]
i1 <- 1:54
i2 <- 55:108
i2d <- 55:109
tb <- matrix(NA, nrow=2, ncol=2, dimnames = list(c("i1", "i2"), c("D", "N-D")))
tb
tb["i1","D"] <- sum(data[i1,"Drought"])
tb["i1","N-D"] <- length(i1) - sum(data[i1,"Drought"])
tb["i2","D"] <- sum(data[i2,"Drought"])
tb["i2","N-D"] <- length(i2) - sum(data[i2,"Drought"])
tb
13+41
22+32
ft_new <- fisher.test(tb)
ft_new
data[109,"Drought"] <- c(0) # no drought
data
tb["i1","D"] <- sum(data[i2d,"Drought"])
tb["i2","N-D"] <- length(i2d) - sum(data[i2d,"Drought"])
tb
tb <- matrix(NA, nrow=2, ncol=2, dimnames = list(c("i1", "i2"), c("D", "N-D")))
tb["i1","D"] <- sum(data[i1,"Drought"])
tb["i1","N-D"] <- length(i1) - sum(data[i1,"Drought"])
tb["i2","D"] <- sum(data[i2,"Drought"])
tb["i2","N-D"] <- length(i2) - sum(data[i2,"Drought"])
tb
tb["i2","D"] <- sum(data[i2d,"Drought"])
tb["i2","N-D"] <- length(i2d) - sum(data[i2d,"Drought"])
tb
ftd0_new <- fisher.test(tb) # FTRN (more strongly); sample estimated odds ratio = 0.67; p-value = 0.5548
ftd0_new
data[109,"Drought"] <- c(1) # drought
tb["i2","D"] <- sum(data[i2d,"Drought"])
tb["i2","N-D"] <- length(i2d) - sum(data[i2d,"Drought"])
tb
ftd1_new <- fisher.test(tb) # FTRN (more weakly); sample estimated odds ratio = 0.51; p-value = 0.2474
ftd1_new
ft_new
1-099
1-.099
1-0.90
data[109,"Drought"] <- c(1) # drought
tb["i2","D"] <- sum(data[i2d,"Drought"])
tb["i2","N-D"] <- length(i2d) - sum(data[i2d,"Drought"])
tb
ftd1_new <- fisher.test(tb) # FTRN (more weakly); sample estimated odds ratio = 0.51; p-value = 0.2474
ftd1_new
tb
0.1644-2.2925
0.184-1.135
-2.1281/-0.951
?fisher.test
rm(list= ls());
master <- "/Users/mcl/Dropbox/Year4/random/drought"
setwd(master)
data <- read.csv("drought.csv")
data[109,] <- c(2014,NA) # no drought
i20 <- which(data[ ,'Year'] %in% 1906:1999)
i21 <- which(data[ ,'Year'] %in% 2000:2013)
i21d <- which(data[ ,'Year'] %in% 2000:2014)
rm(list= ls());
master <- "/Users/mcl/Dropbox/Year4/random/drought"
setwd(master)
data <- read.csv("drought.csv")
data[109,] <- c(2014,NA) # no drought
i20 <- which(data[ ,'Year'] %in% 1906:1999)
i21 <- which(data[ ,'Year'] %in% 2000:2013)
i21d <- which(data[ ,'Year'] %in% 2000:2014)
bt20 <- binom.test(sum(data[i20,"Drought"]), length(i20), p = 0.3)
bt20
bt21 <- binom.test(sum(data[i21,"Drought"]), length(i21), p = 0.3)
bt21
bt21d0 <- binom.test(sum(data[i21d,"Drought"]), length(i21d), p = 0.3)
data[109,"Drought"] <- c(0) # no drought
bt21d0 <- binom.test(sum(data[i21d,"Drought"]), length(i21d), p = 0.3)
bt21d0
bt21d1 <- binom.test(sum(data[i21d,"Drought"]), length(i21d), p = 0.3)
bt21d1
rm(list= ls());
master <- "/Users/mcl/Dropbox/Year4/random/drought"
setwd(master)
data <- read.csv("drought.csv")
data[109,] <- c(2014,NA) # no drought
i20 <- which(data[ ,'Year'] %in% 1906:1999)
i21 <- which(data[ ,'Year'] %in% 2000:2013)
i21d <- which(data[ ,'Year'] %in% 2000:2014)
sum(data[i20,"Drought"])
length(i20)
sum(data[i21,"Drought"])
length(i21)
data[109,"Drought"] <- c(0) # no drought
sum(data[i21d,"Drought"])
length(i21d)
sum(data[i21d,"Drought"])
length(i21d)
data[109,"Drought"] <- c(1) # drought
sum(data[i21d,"Drought"])
length(i21d)
binom.test(sum(data[i21d,"Drought"]), length(i21d), p = 0.3)
binom.test(sum(data[i21d,"Drought"]), length(i21d), p = 0.31)
?binom.test
rm(list= ls());
master <- "/Users/mcl/Dropbox/Year4/random/drought"
setwd(master)
data <- read.csv("drought.csv")
data[109,] <- c(2014,NA) # no drought
i20 <- which(data[ ,'Year'] %in% 1906:1999)
i21 <- which(data[ ,'Year'] %in% 2000:2013)
i21d <- which(data[ ,'Year'] %in% 2000:2014)
binom.test(sum(data[i20,"Drought"]), length(i20), p = 0.31)
binom.test(sum(data[i21,"Drought"]), length(i21), p = 0.31)
data[109,"Drought"] <- c(0) # no drought
binom.test(sum(data[i21d,"Drought"]), length(i21d), p = 0.31)
data[109,"Drought"] <- c(1) # drought
binom.test(sum(data[i21d,"Drought"]), length(i21d), p = 0.31)
library(sensitivity)
?sensitivity
library(CorSens)
N <- 10^5
k <- 4
distributions <- c("gamma", "norm","lnorm", "unif")
# Toy model
toy <- function(data){
Y <- (data[ ,1]*data[ ,2]) + (data[ ,1]*data[ ,4])^2 + data[ ,1] + data[ ,2] + data[ ,3] + data[ ,4]
return(Y)
}
# Generate fitted, correlated normals
u <- matrix(runif((k) * N), nrow = N)
xt <- qnorm(u) # normal inverse transform
mu_x <- rep(0,4) # mean vector
rho <- 0.0
sigma <- matrix(rep(NA, k^2), nrow=k) # cor mat init
std <- 1
diag(sigma) <- std^2 ; sigma[lower.tri(sigma)] <- rho ; sigma[upper.tri(sigma)] <- rho
sigma
A <- t(chol(sigma))
x <- t( apply(A %*% t(xt), MARGIN=2, FUN=function(x){x + mu_x}))
A
U <- apply(x,2,pnorm)
U
x1 <-  qgamma(U[,1], shape=1, rate=1/2) # Exp
x2 <- qnorm(U[,2]) # normal
x3 <-  qlnorm(U[,3]) # lognormal
x4 <- qunif(U[,4]) # uniform
data <- cbind(x1,x2,x3,x4)
head(data)
cov(data)
round(cov(data),2)
N
round(cov(data),1)
sigma
print(round(cov(data),1), digits=1)
round(cov(data),1)
round(cov(data),2)
round(cov(data),1)
library(CorSens)
N <- 10^4
k1_ex <- K12(N=N, sigma = round(cov(data),1), mu = rep(0,4), distributions=distributions, model = toy)
distributions
mu_x
k1_ex <- K12(N=N, data = data, distributions=distributions, model = toy)
k1_ex <- K12(N=N, sigma = round(cov(data),1), mu = rep(0,4), distributions=distributions, model = toy)
K12
?K12
library(sensitivity)
# this function requires making two separate samples (a,b)
n_samps <- N
a <- data[sample(nrow(data),size=n_samps,replace=TRUE), ]
b <- data[sample(nrow(data),size=n_samps,replace=TRUE), ]
s1_ex <- sobol2002(model = toy, X1 = a, X2 = b)
s1_ex
library(CorSens)
k1_ex <- K12(N=N, data = data, distributions=distributions, model = toy)
names(s1_ex)
s1_ex$S
s1_ex$T
?sobol2002
names(k1_ex)
?library
rho <- 0.0
sigma <- matrix(rep(NA, k^2), nrow=k) # cor mat init
std <- 1
diag(sigma) <- std^2 ; sigma[lower.tri(sigma)] <- rho ;
sigma[upper.tri(sigma)] <- rho
rhos1 <- 0.8
sigma[2,1] <- sigma[1,2] <- rhos1
sigma
rm(list= ls());
master <- "/Users/mcl/Dropbox/Year3/STATS_MA/code/final/CorSens_package/CorSens"
setwd(master)
library(devtools)
library(roxygen2)
load_all(master, T)
document(".")
check_doc()
test()
check()
